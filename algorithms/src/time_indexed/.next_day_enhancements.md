# ‚è±Ô∏è PERFORMANCE ENHANCEMENT TODOs
> Goal: Microsecond- or nanosecond-level performance for real-time arbitrage applications.

This roadmap outlines the planned optimizations for each time-indexed algorithm to enable ultra-high-frequency performance.

---

## ‚úÖ General Goals (All Structures)
- [ ] Migrate `Arc<Mutex<...>>` ‚Üí Lock-free structures where possible.
- [ ] Preallocate all internal buffers to eliminate heap allocations.
- [ ] Replace `BTreeSet` with faster alternatives (e.g., `FxHashSet`, `IndexSet`, or flat vecs if sortedness not required).
- [ ] Add SIMD-based TTL range checks (where applicable).
- [ ] Integrate per-core sharding and thread-local variants.
- [ ] Benchmark under:
  - Low, medium, high TTL distributions
  - High-concurrency inserts/reads
  - 1M+ insert stress tests
- [ ] Add detailed memory profiling for inserts and ticks.

---

## ‚è≥ SkipListExpiry
- [ ] Replace `VecDeque<BTreeSet<T>>` with flat ring buffer or slab allocator.
- [ ] Investigate using `arrayvec` or `heapless` to store time buckets.
- [ ] Optimize `.tick()` to avoid full list traversal.
- [ ] Remove `HashMap<T, usize>` if not strictly needed or batch-compact it.

---

## üßµ TimeSegmentedHeap
- [ ] Replace internal bucket Vecs with static arrays (e.g., `[Vec<T>; N]` via `array-init`).
- [ ] Enable batch expiry across multiple segments using Rayon.
- [ ] Move to bucket index tracking for O(1) removals.
- [ ] SIMD-accelerate the TTL expiration conditions.

---

## üîÅ TimingWheel
- [ ] Flatten `VecDeque<HashSet<T>>` into contiguous slab or array-backed slots.
- [ ] Introduce a ring-buffered clock with fast rollover detection.
- [ ] Offload `.tick()` to a fixed-time interval thread with real-time OS scheduling.
- [ ] Ensure inserts are lock-free via per-slot atomic queues or lock striping.

---

## üß™ Benchmarking Enhancements
- [ ] Add micro-benchmarks for each structure: `insert`, `tick`, `tick+insert`, `tick+GC`
- [ ] Add stress benchmarks:
  - [ ] 1 million inserts with randomized TTLs
  - [ ] Uniform skewed TTL patterns (front/back loaded)
- [ ] Add benchmark output to CSV for offline analysis
- [ ] Profile memory consumption per TTL strategy
- [ ] Measure overhead of tick thread vs manual tick

---

## üî¨ Future Enhancements
- [ ] Use memory-mapped ring buffers for TTL buckets
- [ ] Explore offloading expiry ticks to `tokio` runtime or `crossbeam` threadpools
- [ ] Integrate `tracing` and `metrics` for in-flight latency profiling
- [ ] Add `--release` profiling mode via `perf` and flamegraph tooling

---

## üß† Ultimate Goal
Achieve:
- Inserts ‚â§ **2Œºs**
- Tick ‚â§ **200ns** per expired bucket
- Lock-free operation for arbitrage-sensitive workloads
- Full readiness for global-scale trading systems

---
