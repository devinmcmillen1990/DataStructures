===========================
ğŸ“˜ LevelIndexedSkipList Notes
===========================

ğŸ¯ Goal:
A hierarchical, time-aware data structure inspired by skip lists, where items are inserted into "levels" based on their expiration time. Lower levels = soon-to-expire, higher levels = longer-term scheduling.

---

ğŸ§± Structure Overview:

- Vec<BTreeSet<T>> â†’ each index is a level (0 = soonest, num_levels-1 = farthest)
- id_to_level: HashMap<T, usize> â†’ tracks which level an ID is currently in
- insert(id, level): places id in the given level bucket
- expire_front(): finds first non-empty level, expires its contents

---

ğŸ“Š Visual:

Time cascades from top to bottom like an hourglass. Items fall closer to the base as expiration nears.

Top Level (coarse expiry)
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Level 3 â”‚ [ ]          â”‚  â† Longest-living items
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Level 2 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ [ ]          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Level 1 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ [ ]          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Level 0 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ [A, B, C]    â”‚  â† Soonest to expire
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†‘  â†‘  â†‘
     expire_front() will expire all items in Level 0

---

ğŸ§  Key Rules:

â€¢ insert(id, level):
    - Removes the item from its previous level (if exists)
    - Adds it to the new level bucket

â€¢ expire_front():
    - Scans levels in order (0 to N)
    - Returns and clears first non-empty level
    - Cleans up id_to_level mapping

â€¢ promote_or_cleanup(): [optional]
    - Could periodically shift items from coarse to fine levels as time passes

---

ğŸ” Example Flow:

1. insert("A", 2)
2. insert("B", 0)
3. insert("C", 1)

Levels:
Level 0 â†’ [B]
Level 1 â†’ [C]
Level 2 â†’ [A]

4. expire_front() â†’ returns ["B"]
5. expire_front() â†’ returns ["C"]
6. expire_front() â†’ returns ["A"]
7. expire_front() â†’ returns []

---

ğŸ§° Implementation Notes:

- Each level uses a BTreeSet for:
  - Sorted iteration (if needed)
  - Fast insertion/removal
- id_to_level ensures uniqueness and O(1) lookup during expiration
- Vec<BTreeSet<T>> allows easy expansion or compression of levels

---

âœ… Advantages:

- Simpler than traditional skip lists
- Better than flat bucket systems for unevenly distributed timeouts
- Cascading structure makes it flexible for multi-resolution timing

---

âš ï¸ Limitations:

- Not thread-safe (global state)
- Items must be explicitly promoted if time resolution drifts
- Optimal level computation must be externally managed

---
